categories: Note

tags:

- Web
- JS

date: 2015-01-15

toc: true

title: JS 传参方式与作用域基础
---

JS 这门「2014 年度语言」虽然易于上手，但是进阶路上的坑真心多，一不小心就会被种种反直觉的行为所迷惑。以下是对一些 JS 常识级问题的整理和总结。

<!--more-->

## 值传递与引用传递
为了搞清在执行最基本的赋值语句，即

``` js
var a = b;
```

时发生了什么的问题，有必要分清值传递和引用传递这两个概念。

* **值传递**相当于一份全新的拷贝，将这份拷贝放在另一个内存地址里。
* **引用传递**相当于为这两个变量指定同一个地址，即新变量是对旧变量的一个引用。

而 JS 作为弱类型语言，它的赋值语句既有值传递，又有引用传递：

* 对基本类型（`undefined` / `null` / `boolean` / `number` / `string`）使用值传递
* 对引用类型（除基本类型外的其它类型，如 `Array` / `Object` 等）使用引用传递


这就造成了一个潜在的问题：

这是符合直觉的

``` js
var a = 0;
b = a;
a++;
alert(b); // 0
```

但这是反直觉的

``` js
var a = [0, 1];
b = a;
a[0]++;
alert(b); // 1, 1
```

由于 `a` 与 `b` 实际上都是对同一个变量的引用，因此修改 `a` 会改变 `b` 的值。这种情况下，要想符合直觉地赋值，就需要一个 `for` 遍历来做深拷贝。

## 函数的参数传递
在上面的基础上，就可以分辨 JS 中一个常见的误区了：**实际上，所有函数的参数都是按值传递的**，而不是既有值传递，又有引用传递。

对基本类型使用值传递很符合直觉，那么对象呢？以下代码可能会让你误以为函数使用了值传递：

``` js
function set(obj) {
	obj.name = "JunkSript";
}
var js = new Object();
set(js);
alert(js.name); // JunkScript
```

函数修改了传入实参的值，这初看之下是引用传递。但实际上在传入函数时，传入了 `js` 的一个完整副本，但这个副本和 js 引用的是同一个对象：它们是两个有相同引用值的独立变量。对以上代码稍加修改如下：

``` js
function set(obj) {
	obj.name = "JunkSript";
	obj = new Object();
	obj.name = "JavaScript"
}
var js = new Object();
set(js);
alert(js.name); // JunkScript
```

虽然函数内部的局部变量 `obj` 的 `name` 属性是 `JavaScript`，但输出是 `JunkScript`。理由很简单：`obj` 由值传递获得，给它一个新引用（重写）后就是一个分分钟被 GC 的局部对象了。

## 执行环境与作用域
JS 的变量和函数都放在执行环境中，解释器每次遇见一个变量名，都通过作用域链机制在执行环境中查找。这个机制的基本特点是逐级向上（从内到外）查找：内部作用域里能访问外部作用域，而外部作用域访问不了内部作用域。

从而，函数能访问未传入的外部变量（内部作用域能访问外部），而外部变量访问不了函数的内部作用域（反之不行）。

这个机制的副作用就是 JS 没有符合直觉的块级作用域：

``` js
if (true) {
	var js = "JunkScript";
}
alert(js); //JunkScript
```

`js` 变量在赋值后，并没有在离开花括号作用域后被销毁。同样地，`for` 语句中的初始化变量也不会在循环结束后被销毁，这也需要格外的注意。

至于使用 `var` 声明的变量会被添加到最近的执行环境中，而直接声明的变量会被添加到全局环境中，就是老生常谈的了。
